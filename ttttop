import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.server.WebFilter;
import org.springframework.web.server.WebFilterChain;
import reactor.core.publisher.Mono;
import org.springframework.http.HttpStatus;

public class MiFiltro implements WebFilter {

    private final MiServicio miServicio; // Inyectamos el servicio

    public MiFiltro(MiServicio miServicio) {
        this.miServicio = miServicio;
    }

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {
        return miServicio.hacerPeticion()
                .flatMap(response -> {
                    // Si la petición fue exitosa, continuamos con el flujo
                    return chain.filter(exchange);
                })
                .onErrorResume(e -> {
                    // Verificamos si el error es una excepción TipoErrorException
                    if (e instanceof TipoErrorException) {
                        Notificacion notificacion = ((TipoErrorException) e).getTipoError();
                        // Ahora agregamos la notificación al response del exchange
                        exchange.getResponse().setStatusCode(HttpStatus.BAD_REQUEST);  // O el código adecuado
                        exchange.getResponse().getHeaders().set("Error-Message", notificacion.getMensaje());
                        exchange.getResponse().getHeaders().set("Error-Code", notificacion.getCodigo());
                        return exchange.getResponse().setComplete();  // Detenemos el flujo
                    }

                    // Si el error no es de tipo TipoErrorException, lo tratamos como un error genérico
                    exchange.getResponse().setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR);
                    return exchange.getResponse().setComplete();  // Detenemos el flujo
                });
    }
}