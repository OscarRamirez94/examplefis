import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import static org.junit.jupiter.api.Assertions.*;

import java.util.HashMap;
import java.util.Map;

class AccountServiceImplTest {

    private AccountServiceImpl accountService;
    private BiocatchDto biocatchDto;
    private BackendSession backendSession;

    @BeforeEach
    void setup() {
        accountService = new AccountServiceImpl();
        biocatchDto = Mockito.mock(BiocatchDto.class);
        backendSession = Mockito.mock(BackendSession.class);

        // Simulamos la cadena de llamadas: requestModel.getRequestSession().getBackendSession()
        RequestSession requestSession = Mockito.mock(RequestSession.class);
        Mockito.when(biocatchDto.getRequestSession()).thenReturn(requestSession);
        Mockito.when(requestSession.getBackendSession()).thenReturn(backendSession);
    }

    @Test
    void shouldReturnAccountWhenEncryptedAccountExists() {
        Map<String, Object> accounts = new HashMap<>();
        accounts.put("enc123", "plainAccount123");

        Mockito.when(backendSession.getAccounts()).thenReturn(accounts);

        String result = accountService.getAccount("enc123", biocatchDto);

        assertEquals("plainAccount123", result);
    }

    @Test
    void shouldReturnNullWhenAccountDoesNotExist() {
        Map<String, Object> accounts = new HashMap<>();
        Mockito.when(backendSession.getAccounts()).thenReturn(accounts);

        String result = accountService.getAccount("missingKey", biocatchDto);

        assertNull(result);
    }

    @Test
    void shouldReturnParsedAccountWhenOnlyPlainAccountExists() {
        Map<String, String> plainMap = new HashMap<>();
        plainMap.put("ACCOUNT_PLAIN_BACKEND_SESSION", "accountValue|extraData");

        Map<String, Object> accounts = new HashMap<>();
        accounts.put("ACCOUNTS_PLAIN_BACKEND_SESSION", plainMap);

        Mockito.when(backendSession.getAccounts()).thenReturn(accounts);

        String result = accountService.getAccount("notEncrypted", biocatchDto);

        assertEquals("accountValue", result);
    ‚Ññ##########





security:
  allowed-hosts:
    - api.dev.midominio.com
    - auth.dev.midominio.com
    - servicios.seguro.com


import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

import java.util.List;

@Component
@ConfigurationProperties(prefix = "security")
public class SecurityProperties {

    private List<String> allowedHosts;

    public List<String> getAllowedHosts() {
        return allowedHosts;
    }

    public void setAllowedHosts(List<String> allowedHosts) {
        this.allowedHosts = allowedHosts;
    }
}

√°aaaaaa
import org.springframework.http.HttpRequest;
import org.springframework.http.client.ClientHttpRequestExecution;
import org.springframework.http.client.ClientHttpRequestInterceptor;
import org.springframework.http.client.ClientHttpResponse;

import java.io.IOException;
import java.net.InetAddress;
import java.net.URI;
import java.net.UnknownHostException;
import java.util.List;

public class SafeHostInterceptor implements ClientHttpRequestInterceptor {

    private final List<String> allowedHosts;

    public SafeHostInterceptor(List<String> allowedHosts) {
        this.allowedHosts = allowedHosts;
    }

    @Override
    public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution)
            throws IOException {

        URI uri = request.getURI();
        validateUri(uri);

        return execution.execute(request, body);
    }

    private void validateUri(URI uri) throws IOException {
        String host = uri.getHost();

        // ‚úÖ Validar lista blanca desde application.yml
        if (!allowedHosts.contains(host)) {
            throw new IOException("Host no permitido: " + host);
        }

        // ‚úÖ Bloquear loopback, privados, etc.
        try {
            InetAddress addr = InetAddress.getByName(host);
            if (addr.isAnyLocalAddress() || addr.isLoopbackAddress() || addr.isSiteLocalAddress()) {
                throw new IOException("Host bloqueado (privado/loopback): " + host);
            }
        } catch (UnknownHostException e) {
            throw new IOException("No se puede resolver el host: " + host);
        }
    }
}

aaaa

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class RestTemplateConfig {

    private final SecurityProperties securityProperties;

    public RestTemplateConfig(SecurityProperties securityProperties) {
        this.securityProperties = securityProperties;
    }

    @Bean
    public RestTemplate restTemplate() {
        RestTemplate restTemplate = new RestTemplate();
        restTemplate.getInterceptors().add(
            new SafeHostInterceptor(securityProperties.getAllowedHosts())
        );
        return restTemplate;
    }
}


logging:
  level:
    org.springframework.web.client.RestTemplate: DEBUG
    org.springframework.http.client: DEBUG
    org.apache.http: DEBUG

!!!@


package com.tuempresa.config;

import java.util.List;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

@Configuration
@EnableWebSecurity
@Profile("dev") // <-- esta clase solo se activa en el perfil 'dev'
public class SecurityConfigDev {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            // üîí Desactiva CSRF y permite CORS desde el frontend local
            .csrf(csrf -> csrf.disable())
            .cors(cors -> cors.configurationSource(corsConfigurationSource()))
            // üîí No guarda sesiones
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            // üîì Permite todas las peticiones
            .authorizeHttpRequests(auth -> auth
                .anyRequest().permitAll()
            )
            // üö´ Desactiva por completo la validaci√≥n JWT
            .oauth2ResourceServer(oauth2 -> oauth2.disable());

        return http.build();
    }

    // üåç Permite llamadas desde localhost:9099 (frontend local)
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowedOrigins(List.of("http://localhost:9099"));
        config.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        config.setAllowedHeaders(List.of("*"));
        config.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);
        return source;
    }
}



Map<String, Object> datos = new HashMap<>();
datos.put("nombre", "Ana");
datos.put("edad", 30);

PersonaDTO persona = new PersonaDTO();
persona.setNombre(String.valueOf(datos.getOrDefault("nombre", "")));
persona.setApellido(String.valueOf(datos.getOrDefault("apellido", "")));




repositories {
    flatDir {
        dirs '/ruta/a/mis/jars'
    }
}

dependencies {
    implementation name: 'ejemplo'
}



logging:
  level:
    feign: DEBUG
    feign.Logger: DEBUG
    org.springframework.cloud.openfeign: DEBUG
    feign.client: DEBUG
    com.netflix.loadbalancer: DEBUG