@RestController
@RequestMapping("/api/filtrado")
public class FiltradoController {

    private final FiltroServicio filtroServicio;

    public FiltradoController(FiltroServicio filtroServicio) {
        this.filtroServicio = filtroServicio;
    }

    @GetMapping
    public Mono<ResponseEntity<Flux<RespuestaExterna>>> obtenerFiltrado(@RequestParam(defaultValue = "I") String status) {
        Flux<RespuestaExterna> flujoFiltrado = filtroServicio.filtrarPorStatus(status);

        return Mono.just(
            ResponseEntity.ok(flujoFiltrado)
        );
    }
}



@Service
public class ClienteServicioExterno {

    private final WebClient webClient;

    public ClienteServicioExterno(WebClient webClient) {
        this.webClient = webClient;
    }

    public Flux<RespuestaExterna> obtenerDatos() {
        return webClient.get()
            .uri("/api/external") // Cambia esta URI por la real
            .retrieve()
            .bodyToFlux(RespuestaExterna.class);
    }
}


@Service
public class FiltroServicio {

    private final ClienteServicioExterno clienteServicioExterno;

    public FiltroServicio(ClienteServicioExterno clienteServicioExterno) {
        this.clienteServicioExterno = clienteServicioExterno;
    }

    public Flux<RespuestaExterna> filtrarPorStatus(String status) {
        return clienteServicioExterno.obtenerDatos()
            .map(respuestaExterna -> {
                // Si hay errores, retornamos la respuesta tal cual
                if (respuestaExterna.getErrores() != null && !respuestaExterna.getErrores().isEmpty()) {
                    return respuestaExterna;
                }

                // Si no hay errores, filtramos la lista de resultados por status
                List<StatusDto> filtrados = respuestaExterna.getResultados().stream()
                        .filter(dto -> status.equalsIgnoreCase(dto.getStatus()))
                        .collect(Collectors.toList());

                // Creamos una nueva respuesta con los resultados filtrados
                respuestaExterna.setResultados(filtrados);
                return respuestaExterna;
            });
    }
}



public Mono<ResponseEntity<RespuestaFiltrada>> filtrarPorStatus(String status) {
    return clienteServicioExterno.obtenerDatos()
        .flatMap(respuestaExterna -> {
            if (respuestaExterna == null) {
                return Mono.just(ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(new RespuestaFiltrada(Collections.emptyList(), "Respuesta externa nula", "500")));
            }

            if (respuestaExterna.getErrores() != null && !respuestaExterna.getErrores().isEmpty()) {
                return Mono.just(ResponseEntity
                    .badRequest()
                    .body(new RespuestaFiltrada(Collections.emptyList(), "Errores encontrados", "400")));
            }

            List<StatusDto> resultados = Optional.ofNullable(respuestaExterna.getResultados()).orElse(Collections.emptyList());

            List<NuevoDto> nuevaLista = resultados.stream()
                .filter(dto -> status.equalsIgnoreCase(dto.getStatus()))
                .map(dto -> new NuevoDto(dto.getStatus(), "DescripciÃ³n " + dto.getStatus()))
                .collect(Collectors.toList());

            if (nuevaLista.isEmpty()) {
                return Mono.just(ResponseEntity.noContent().build());
            }

            return Mono.just(ResponseEntity.ok(new RespuestaFiltrada(nuevaLista, "Filtrado exitoso", "200")));
        })
        .switchIfEmpty(Mono.just(ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(new RespuestaFiltrada(Collections.emptyList(), "Error inesperado", "500"))));
}



@ExtendWith(MockitoExtension.class)
class FiltroServicioTest {

    @Mock
    private ClienteServicioExterno clienteServicioExterno;

    private FiltroServicio filtroServicio;

    @BeforeEach
    void setUp() {
        filtroServicio = new FiltroServicio(clienteServicioExterno);
    }

    @Test
    void debeRetornarRespuestaFiltradaExitosa() {
        StatusDto dto1 = new StatusDto("I", LocalDate.now());
        StatusDto dto2 = new StatusDto("A", LocalDate.now());
        RespuestaExterna mockRespuesta = new RespuestaExterna(Collections.emptyList(), List.of(dto1, dto2));

        Mockito.when(clienteServicioExterno.obtenerDatos()).thenReturn(Mono.just(mockRespuesta));

        filtroServicio.filtrarPorStatus("I")
            .as(StepVerifier::create)
            .expectNextMatches(resp -> resp.getStatusCode().is2xxSuccessful()
                && resp.getBody() != null
                && resp.getBody().getListaFiltrada().size() == 1
                && resp.getBody().getListaFiltrada().get(0).getStatus().equals("I"))
            .verifyComplete();
    }

    @Test
    void debeRetornarNoContentSiNoHayCoincidencias() {
        StatusDto dto = new StatusDto("A", LocalDate.now());
        RespuestaExterna respuesta = new RespuestaExterna(Collections.emptyList(), List.of(dto));

        Mockito.when(clienteServicioExterno.obtenerDatos()).thenReturn(Mono.just(respuesta));

        filtroServicio.filtrarPorStatus("I")
            .as(StepVerifier::create)
            .expectNextMatches(resp -> resp.getStatusCode().equals(HttpStatus.NO_CONTENT))
            .verifyComplete();
    }

    @Test
    void debeRetornarBadRequestSiHayErrores() {
        RespuestaExterna respuesta = new RespuestaExterna(List.of("Error"), Collections.emptyList());

        Mockito.when(clienteServicioExterno.obtenerDatos()).thenReturn(Mono.just(respuesta));

        filtroServicio.filtrarPorStatus("I")
            .as(StepVerifier::create)
            .expectNextMatches(resp -> resp.getStatusCode().equals(HttpStatus.BAD_REQUEST))
            .verifyComplete();
    }

    @Test
    void debeRetornarErrorSiMonoEsVacio() {
        Mockito.when(clienteServicioExterno.obtenerDatos()).thenReturn(Mono.empty());

        filtroServicio.filtrarPorStatus("I")
            .as(StepVerifier::create)
            .expectNextMatches(resp -> resp.getStatusCode().equals(HttpStatus.INTERNAL_SERVER_ERROR))
            .verifyComplete();
    }
}


@ExtendWith(MockitoExtension.class)
class FiltradoControllerTest {

    @Mock
    private FiltroServicio filtroServicio;

    private FiltradoController controller;

    @BeforeEach
    void setUp() {
        controller = new FiltradoController(filtroServicio);
    }

    @Test
    void debeRetornarResponseEntityDesdeServicio() {
        RespuestaFiltrada mockBody = new RespuestaFiltrada(List.of(new NuevoDto("I", "desc")), "OK", "200");
        ResponseEntity<RespuestaFiltrada> response = ResponseEntity.ok(mockBody);

        Mockito.when(filtroServicio.filtrarPorStatus("I")).thenReturn(Mono.just(response));

        controller.obtenerFiltrado("I")
            .as(StepVerifier::create)
            .expectNext(response)
            .verifyComplete();
    }
}