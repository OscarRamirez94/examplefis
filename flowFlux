




controller 

@RestController
@RequestMapping("/api/filtrado")
public class FiltradoController {

    private final ClienteServicioExterno clienteServicioExterno;
    private final FiltroServicio filtroServicio;

    public FiltradoController(ClienteServicioExterno clienteServicioExterno, FiltroServicio filtroServicio) {
        this.clienteServicioExterno = clienteServicioExterno;
        this.filtroServicio = filtroServicio;
    }

    @GetMapping
    public Mono<ResponseEntity<DtoFiltrado>> obtenerFiltrado() {
        return clienteServicioExterno.obtenerDatos()
            .map(filtroServicio::filtrarPorStatusI)
            .map(ResponseEntity::ok);
    }
}


servicio filtrado 

@Service
public class FiltroServicio {

    public DtoFiltrado filtrarPorStatusI(Dto dto) {
        if (dto.getErrores() != null && !dto.getErrores().isEmpty()) {
            return new DtoFiltrado(dto.getErrores(), Collections.emptyList());
        }

        List<StatusFechaDto> filtrados = dto.getResultados().stream()
            .filter(r -> "I".equals(r.getStatus()))
            .collect(Collectors.toList());

        return new DtoFiltrado(Collections.emptyList(), filtrados);
    }
}



servicio orquestado 


@Service
public class ClienteServicioExterno {

    public Mono<Dto> obtenerDatos() {
        // Aquí iría el WebClient real. Simulamos respuesta.
        Dto dto = new Dto();

        // Simulamos sin errores y con resultados
        dto.setErrores(Collections.emptyList());

        List<StatusFechaDto> resultados = List.of(
            new StatusFechaDto("A", LocalDate.now()),
            new StatusFechaDto("I", LocalDate.now().minusDays(1)),
            new StatusFechaDto("I", LocalDate.now().minusDays(2))
        );

        dto.setResultados(resultados);

        return Mono.just(dto);
    }
}



en flux.....



@RestController
@RequestMapping("/api/filtrado")
public class FiltradoController {

    private final ClienteServicioExterno clienteServicioExterno;
    private final FiltroServicio filtroServicio;

    public FiltradoController(ClienteServicioExterno clienteServicioExterno, FiltroServicio filtroServicio) {
        this.clienteServicioExterno = clienteServicioExterno;
        this.filtroServicio = filtroServicio;
    }

    @GetMapping
    public Mono<ResponseEntity<?>> obtenerFiltrado(@RequestParam(defaultValue = "I") String status) {
        return clienteServicioExterno.obtenerErrores()
            .flatMap(errores -> {
                if (!errores.isEmpty()) {
                    return Mono.just(ResponseEntity.badRequest().body(Map.of("errores", errores)));
                } else {
                    Flux<StatusDto> resultadosFiltrados = filtroServicio
                        .filtrarPorStatus(clienteServicioExterno.obtenerResultados(), status);

                    return Mono.just(ResponseEntity.ok(resultadosFiltrados));
                }
            });
    }
}


@Service
public class FiltroServicio {

    public Flux<StatusDto> filtrarPorStatus(Flux<StatusDto> flujo, String status) {
        return flujo.filter(dto -> status.equalsIgnoreCase(dto.getStatus()));
    }
}


@Service
public class ClienteServicioExterno {

    public Mono<List<ErrorDto>> obtenerErrores() {
        // Simula sin errores
        return Mono.just(Collections.emptyList());
    }

    public Flux<StatusDto> obtenerResultados() {
        List<StatusDto> resultados = List.of(
            new StatusDto("A"),
            new StatusDto("I"),
            new StatusDto("I")
        );
        return Flux.fromIterable(resultados);
    }
}


@Service
public class ClienteServicioExterno {

    private final WebClient webClient;

    public ClienteServicioExterno(WebClient webClient) {
        this.webClient = webClient;
    }

    public Mono<List<ErrorDto>> obtenerErrores() {
        return webClient.get()
            .uri("/api/external") // Ajusta el path
            .retrieve()
            .bodyToMono(RespuestaExterna.class)
            .map(RespuestaExterna::getErrores);
    }

    public Flux<StatusDto> obtenerResultados() {
        return webClient.get()
            .uri("/api/external")
            .retrieve()
            .bodyToMono(RespuestaExterna.class)
            .flatMapMany(respuesta -> Flux.fromIterable(respuesta.getResultados()));
    }
}


mix @Service
public class FiltroServicio {

    public RespuestaExterna filtrarPorStatus(RespuestaExterna original, String status) {
        if (original.getErrores() != null && !original.getErrores().isEmpty()) {
            return original; // No se modifica si hay errores
        }

        List<StatusDto> filtrados = original.getResultados().stream()
            .filter(dto -> status.equalsIgnoreCase(dto.getStatus()))
            .collect(Collectors.toList());

        RespuestaExterna respuesta = new RespuestaExterna();
        respuesta.setErrores(Collections.emptyList());
        respuesta.setResultados(filtrados);
        respuesta.setCodigo(original.getCodigo());
        respuesta.setMensaje(original.getMensaje());

        return respuesta;
    }
}



@RestController
@RequestMapping("/api/filtrado")
public class FiltradoController {

    private final ClienteServicioExterno clienteServicioExterno;
    private final FiltroServicio filtroServicio;

    public FiltradoController(ClienteServicioExterno clienteServicioExterno, FiltroServicio filtroServicio) {
        this.clienteServicioExterno = clienteServicioExterno;
        this.filtroServicio = filtroServicio;
    }

    @GetMapping
    public Mono<ResponseEntity<RespuestaExterna>> obtenerFiltrado(@RequestParam(defaultValue = "I") String status) {
        return clienteServicioExterno.obtenerDatos()
            .map(dto -> {
                if (dto.getErrores() != null && !dto.getErrores().isEmpty()) {
                    return ResponseEntity.badRequest().body(dto);
                } else {
                    RespuestaExterna filtrada = filtroServicio.filtrarPorStatus(dto, status);
                    return ResponseEntity.ok(filtrada);
                }
            });
    }
}