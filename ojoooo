import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.server.WebFilter;
import org.springframework.web.server.WebFilterChain;
import org.springframework.web.server.ServerWebExchangeUtils;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.ClientResponse;
import reactor.core.publisher.Mono;
import org.springframework.core.io.buffer.DataBuffer;
import org.springframework.core.io.buffer.DataBufferUtils;

@Component
public class CustomGatewayFilter implements WebFilter {

    private final WebClient.Builder webClientBuilder;

    public CustomGatewayFilter(WebClient.Builder webClientBuilder) {
        this.webClientBuilder = webClientBuilder;
    }

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {
        // Hacemos la solicitud al servicio con WebClient
        return webClientBuilder.baseUrl("https://api.exapmle.com")
                .get()  // Aquí utilizamos GET, pero puedes adaptar el método según sea necesario
                .uri("/endpoint")
                .retrieve()
                .onStatus(status -> status.value() == 422, clientResponse -> {
                    // Si la respuesta es 422, leemos el cuerpo original de la respuesta
                    return clientResponse.bodyToMono(String.class)
                            .flatMap(body -> {
                                // Regresamos el cuerpo de la respuesta 422 con el código correspondiente
                                exchange.getResponse().setStatusCode(HttpStatus.UNPROCESSABLE_ENTITY);
                                exchange.getResponse().getHeaders().add("Content-Type", "application/json");
                                
                                // Escribimos el cuerpo de la respuesta original al cliente
                                DataBuffer dataBuffer = exchange.getResponse().bufferFactory().wrap(body.getBytes());
                                return exchange.getResponse().writeWith(Mono.just(dataBuffer))
                                        .then(Mono.defer(() -> {
                                            // Marcamos la respuesta como iniciada y cortamos el flujo
                                            ServerWebExchangeUtils.setResponseStarted(exchange);
                                            return Mono.empty();
                                        }));
                            });
                })
                .flatMap(responseBody -> {
                    // Si la respuesta no es 422, continúa el flujo normal
                    return chain.filter(exchange);
                });
    }
}