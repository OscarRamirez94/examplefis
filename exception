import org.springframework.http.ResponseEntity;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;

public Mono<ResponseEntity<Object>> handleWebClientResponse() {
    return webClient.get()  // O el tipo de solicitud que estés usando
        .uri("tu-url")
        .exchangeToMono(response -> {
            if (response.statusCode().is2xxSuccessful()) {
                // Si el código de estado es 2xx (200, 201, etc.), procesas el cuerpo
                return response.bodyToMono(CreditProductResponse.class)
                    .map(body -> ResponseEntity.ok(body));
            } else if (response.statusCode().value() == 209) {
                // Si el código de estado es 209, regresas el error deseado
                return response.bodyToMono(String.class)
                    .map(errorMessage -> ResponseEntity.status(209).body("Error: " + errorMessage));
            } else if (response.statusCode().is4xxClientError()) {
                // Si el código de estado es 4xx (por ejemplo, 400), lanzas una excepción
                return response.bodyToMono(String.class)
                    .flatMap(errorMessage -> {
                        // Lanzas una excepción con el mensaje de error
                        return Mono.error(new ClientException("Error 400: " + errorMessage));
                    });
            } else {
                // Si no es 2xx ni 209 ni 4xx, se puede devolver la respuesta tal como está
                return Mono.just(ResponseEntity.status(response.statusCode()).build());
            }
        });
}





import org.springframework.http.ResponseEntity;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;

public Mono<ResponseEntity<Object>> handleWebClientResponse() {
    return webClient.get()  // O el tipo de solicitud que estés usando
        .uri("tu-url")
        .exchangeToMono(response -> {
            if (response.statusCode().is2xxSuccessful()) {
                // Si el código de estado es 2xx (200, 201, etc.), procesas el cuerpo
                return response.bodyToMono(CreditProductResponse.class)
                    .map(body -> ResponseEntity.ok(body));
            } else if (response.statusCode().value() == 209) {
                // Si el código de estado es 209, regresas el error deseado
                return response.bodyToMono(String.class)
                    .map(errorMessage -> ResponseEntity.status(209).body("Error: " + errorMessage));
            } else if (response.statusCode().is4xxClientError()) {
                // Si el código de estado es 4xx (por ejemplo, 400), lanzas una excepción
                return response.bodyToMono(String.class)
                    .flatMap(errorMessage -> {
                        // Lanzas una excepción con el mensaje de error
                        return Mono.error(new ClientException("Error 400: " + errorMessage));
                    });
            } else {
                // Si no es 2xx ni 209 ni 4xx, se puede devolver la respuesta tal como está
                return Mono.just(ResponseEntity.status(response.statusCode()).build());
            }
        });
}import org.springframework.http.ResponseEntity;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;

public Mono<ResponseEntity<Object>> handleWebClientResponse() {
    return webClient.get()  // O el tipo de solicitud que estés usando
        .uri("tu-url")
        .exchangeToMono(response -> {
            if (response.statusCode().is2xxSuccessful()) {
                // Si el código de estado es 2xx (200, 201, etc.), procesas el cuerpo
                return response.bodyToMono(CreditProductResponse.class)
                    .map(body -> ResponseEntity.ok(body));
            } else if (response.statusCode().value() == 209) {
                // Si el código de estado es 209, regresas el error deseado
                return response.bodyToMono(String.class)
                    .map(errorMessage -> ResponseEntity.status(209).body("Error: " + errorMessage));
            } else {
                // Si no es 2xx ni 209, puedes devolver una respuesta con el código correspondiente
                return Mono.just(ResponseEntity.status(response.statusCode()).build());
            }
        });
}




import org.springframework.http.HttpStatus;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;

public Mono<ResponseEntity<Object>> handleWebClientResponse() {
    return webClient.get()  // O el tipo de solicitud que estés usando
        .uri("tu-url")
        .exchangeToMono(response -> {
            if (response.statusCode().equals(HttpStatus.OK)) {
                // Si el código de estado es 200 (OK), procesas el cuerpo y lo devuelves
                return response.bodyToMono(CreditProductResponse.class)
                    .map(body -> ResponseEntity.ok(body));
            } else if (response.statusCode().equals(HttpStatus.I_AM_A_TEAPOT)) {  // Código 209
                // Si el código de estado es 209, regresas el error deseado
                return response.bodyToMono(String.class)
                    .map(errorMessage -> ResponseEntity.status(209).body("Error: " + errorMessage));
            } else {
                // Si el código no es 200 ni 209, manejas otros casos como lo desees
                return Mono.just(ResponseEntity.status(response.statusCode()).build());
            }
        });
}









public Mono<Object> obtenerRespuesta() {
    return webClient.get()
            .uri("/tu-endpoint")
            .retrieve()
            .onStatus(HttpStatus::is5xxServerError, response ->
                response.bodyToMono(String.class)  // Leemos el body si es error
                        .map(errorMsg -> {
                            MiObjetoRespuesta obj = new MiObjetoRespuesta();
                            obj.setNotificationMessage(errorMsg); // Guardamos el mensaje
                            return obj;
                        })
                        .flatMap(objeto -> Mono.error(new MiExcepcionConObjeto(objeto)))  // Lanza la excepción
            )
            .onStatus(HttpStatus::is2xxSuccessful, response -> {
                // Aquí simplemente usamos el tipo que deseas deserializar directamente
                return response.bodyToMono(TuClaseRespuesta.class);  // Mapeamos a TuClaseRespuesta
            })
            .doOnError(e -> {
                // Opcional: Manejo de errores global o logging
                System.out.println("Error: " + e.getMessage());
            })
            .onErrorResume(MiExcepcionConObjeto.class, ex -> {
                // Manejo de la excepción personalizada, retornamos el objeto
                return Mono.just(ex.getRespuesta());
            });
}





import org.springframework.core.ParameterizedTypeReference;

public Mono<Object> obtenerRespuesta(String tipoDeRespuesta) {
    return webClient.get()
            .uri("/tu-endpoint")
            .retrieve()
            .onStatus(HttpStatus::is5xxServerError, response ->
                response.bodyToMono(String.class)  // Leemos el body si es error
                        .map(errorMsg -> {
                            MiObjetoRespuesta obj = new MiObjetoRespuesta();
                            obj.setNotificationMessage(errorMsg); // Guardamos el mensaje
                            return obj;
                        })
                        .flatMap(objeto -> Mono.error(new MiExcepcionConObjeto(objeto)))  // Lanza la excepción
            )
            .onStatus(HttpStatus::is2xxSuccessful, response -> {
                // Usamos ParameterizedTypeReference para deserializar dinámicamente
                ParameterizedTypeReference<?> tipoRespuesta = getTipoRespuesta(tipoDeRespuesta);

                // Ahora deserializamos el cuerpo en el tipo adecuado
                return response.bodyToMono(tipoRespuesta);
            })
            .doOnError(e -> {
                // Opcional: Manejo de errores global o logging
                System.out.println("Error: " + e.getMessage());
            })
            .onErrorResume(MiExcepcionConObjeto.class, ex -> {
                // Manejo de la excepción personalizada, retornamos el objeto
                return Mono.just(ex.getRespuesta());
            });
}

// Método para obtener el tipo de respuesta usando ParameterizedTypeReference
private ParameterizedTypeReference<?> getTipoRespuesta(String tipoDeRespuesta) {
    switch (tipoDeRespuesta) {
        case "Tipo1":
            return new ParameterizedTypeReference<Tipo1>() {};  // Instancia de Tipo1
        case "Tipo2":
            return new ParameterizedTypeReference<Tipo2>() {};  // Instancia de Tipo2
        default:
            return new ParameterizedTypeReference<Object>() {}; // Clase predeterminada
    }
}






import org.springframework.core.ParameterizedTypeReference;

public Mono<Object> obtenerRespuesta(String tipoDeRespuesta) {
    return webClient.get()
            .uri("/tu-endpoint")
            .retrieve()
            .onStatus(HttpStatus::is5xxServerError, response ->
                response.bodyToMono(String.class)  // Leemos el body si es error
                        .map(errorMsg -> {
                            MiObjetoRespuesta obj = new MiObjetoRespuesta();
                            obj.setNotificationMessage(errorMsg); // Guardamos el mensaje
                            return obj;
                        })
                        .flatMap(objeto -> Mono.error(new MiExcepcionConObjeto(objeto)))  // Lanza la excepción
            )
            .onStatus(HttpStatus::is2xxSuccessful, response -> {
                // Usamos ParameterizedTypeReference para deserializar dinámicamente
                ParameterizedTypeReference<?> tipoRespuesta = getTipoRespuesta(tipoDeRespuesta);

                // Ahora deserializamos el cuerpo en el tipo adecuado
                return response.bodyToMono(tipoRespuesta);
            })
            .doOnError(e -> {
                // Opcional: Manejo de errores global o logging
                System.out.println("Error: " + e.getMessage());
            })
            .onErrorResume(MiExcepcionConObjeto.class, ex -> {
                // Manejo de la excepción personalizada, retornamos el objeto
                return Mono.just(ex.getRespuesta());
            });
}

// Método para obtener el tipo de respuesta usando ParameterizedTypeReference
private ParameterizedTypeReference<?> getTipoRespuesta(String tipoDeRespuesta) {
    switch (tipoDeRespuesta) {
        case "Tipo1":
            return new ParameterizedTypeReference<Tipo1>() {};  // Instancia de Tipo1
        case "Tipo2":
            return new ParameterizedTypeReference<Tipo2>() {};  // Instancia de Tipo2
        default:
            return new ParameterizedTypeReference<Object>() {}; // Clase predeterminada
    }
}






ķkkkkkk
webClient.get()
         .uri("/tu-endpoint")
         .retrieve()
         .onStatus(HttpStatus::is5xxServerError, response ->
             response.bodyToMono(String.class)  // Leemos el body si es error
                     .map(errorMsg -> {
                         MiObjetoRespuesta obj = new MiObjetoRespuesta();
                         obj.setNotificationMessage(errorMsg); // Guardamos el mensaje
                         return obj;
                     })
                     .flatMap(objeto -> Mono.error(new MiExcepcionConObjeto(objeto)))  // Lanza la excepción
         )
         .onStatus(HttpStatus::is2xxSuccessful, response ->
             response.bodyToMono(TuClaseRespuesta.class)  // Cuando es 200, mapeamos a otro tipo
         )
         .doOnError(e -> {
             // Opcional: Manejo de errores global o logging
             System.out.println("Error: " + e.getMessage());
         })
         .onErrorResume(MiExcepcionConObjeto.class, ex -> {
             // Manejo de la excepción personalizada, retornamos el objeto
             return Mono.just(ex.getRespuesta());
         });







webClient.get()
         .uri("/tu-endpoint")
         .retrieve()
         .onStatus(HttpStatus::is5xxServerError, response ->
             response.bodyToMono(String.class) // El mensaje de error en texto plano
                     .map(msg -> new MiObjetoRespuesta(msg)) // Convertimos el string en tu objeto
                     .flatMap(objeto -> Mono.error(new MiExcepcionConObjeto(objeto)))
         )
         .bodyToMono(TuClaseRespuesta.class);





webClient.get()
         .uri("/tu-endpoint")
         .retrieve()
         .onStatus(HttpStatus::is5xxServerError, response ->
             response.bodyToMono(MiObjetoRespuesta.class)
                     .flatMap(body -> Mono.error(new MiExcepcionConObjeto(body)))
         )
         .bodyToMono(TuClaseRespuesta.class);




webClient.get()
         .uri("/tu-endpoint")
         .retrieve()
         .onStatus(HttpStatus::is5xxServerError, response ->
             response.bodyToMono(String.class)  // Leemos el body si es error
                     .map(errorMsg -> {
                         MiObjetoRespuesta obj = new MiObjetoRespuesta();
                         obj.setNotificationMessage(errorMsg); // Guardamos el mensaje
                         return obj;
                     })
                     .flatMap(objeto -> Mono.error(new MiExcepcionConObjeto(objeto)))
         )
         .onStatus(HttpStatus::is2xxSuccessful, response ->
             response.bodyToMono(TuClaseRespuesta.class)  // Cuando es 200, mapeamos a otro tipo
         )
         .doOnError(e -> {
             // Opcional: Manejo de errores global o logging
             System.out.println("Error: " + e.getMessage());
         })
         .onErrorResume(MiExcepcionConObjeto.class, ex -> {
             // Manejo de la excepción personalizada, retornamos el objeto
             return Mono.just(ex.getRespuesta());
         });