public Mono<PagedResponse<CreditDTO>> getCreditsPaged(Integer cursor, Integer limit) {
    int start = (cursor != null) ? cursor : 0;
    int end = Math.min(start + limit, mockData.size());

    List<CreditDTO> page = mockData.subList(start, end);
    boolean moreRecords = end < mockData.size();
    Integer nextCursor = moreRecords ? end : null;

    return Mono.just(
        new PagedResponse<>(page, nextCursor, moreRecords)
    );
}

,,,,,,,

public class PagedResponse<T> {
    private List<T> data;
    private Integer nextCursor;
    private boolean moreRecords;

    // constructor, getters, setters


........
public Flux<CreditDTO> getCreditsFiltered(String tipo, String status) {
    return getMockCredits()
        .filter(dto -> tipo == null || dto.getTipo().equals(tipo))
        .filter(dto -> status == null || dto.getStatus().equals(status));
}


.........
public class PaginationUtils {

    public static <T> Mono<PagedResponse<T>> paginate(Flux<T> source, Integer cursor, Integer limit) {
        return source.collectList()
            .map(fullList -> {
                int start = (cursor != null) ? cursor : 0;
                int end = Math.min(start + limit, fullList.size());

                List<T> page = fullList.subList(start, end);
                boolean moreRecords = end < fullList.size();
                Integer nextCursor = moreRecords ? end : null;

                return new PagedResponse<>(page, nextCursor, moreRecords);
            });
    }
}

.......


@GetMapping("/credits")
public Mono<ResponseEntity<PagedResponse<CreditDTO>>> getCredits(
        @RequestParam(required = false) Integer cursor,
        @RequestParam(defaultValue = "20") Integer limit,
        @RequestParam(required = false) String status,
        @RequestParam(required = false) String tipo
) {
    return creditService.getPagedCredits(cursor, limit, status, tipo)
        .map(ResponseEntity::ok);
}


 
public Mono<PagedResponse<CreditDTO>> getPagedCredits(
        Integer cursor,
        Integer limit,
        String status,
        String tipo
) {
    return getMockCredits()
        .filter(dto -> status == null || dto.getStatus().equalsIgnoreCase(status))
        .filter(dto -> tipo == null || dto.getTipo().equalsIgnoreCase(tipo))
        .collectList()
        .map(filteredList -> {
            int start = (cursor != null) ? cursor : 0;
            int end = Math.min(start + limit, filteredList.size());

            List<CreditDTO> page = filteredList.subList(start, end);
            boolean moreRecords = end < filteredList.size();
            Integer nextCursor = moreRecords ? end : null;

            return new PagedResponse<>(page, nextCursor, moreRecords);
        });
}
zzzzzzzz

public Mono<PagedResponse<CreditDTO>> getPagedCredits(
        Integer cursor,
        Integer limit,
        String status,
        String tipo
) {
    Flux<CreditDTO> filteredFlux = getMockCredits()
        .filter(dto -> status == null || dto.getStatus().equalsIgnoreCase(status))
        .filter(dto -> tipo == null || dto.getTipo().equalsIgnoreCase(tipo));

    return PaginationUtils.paginate(filteredFlux, cursor, limit);
}




cursor por pagina 

public class PaginationUtils {

    public static <T> Mono<PagedResponse<T>> paginate(Flux<T> source, Integer cursor, Integer limit) {
        return source.collectList()
            .map(fullList -> {
                int currentPage = (cursor != null) ? cursor : 0;
                int start = currentPage * limit;
                int end = Math.min(start + limit, fullList.size());

                List<T> page = (start < fullList.size()) ? fullList.subList(start, end) : List.of();
                boolean moreRecords = end < fullList.size();
                Integer nextCursor = moreRecords ? currentPage + 1 : null;

                return new PagedResponse<>(page, nextCursor, moreRecords);
            });
    }





cursor e Ã­ndice 


public class PaginationUtils {

    public static <T> Mono<PagedResponse<T>> paginate(Flux<T> source, Integer cursor, Integer limit) {
        return source.collectList()
            .map(fullList -> {
                int currentPage = (cursor != null) ? cursor : 0;
                int start = currentPage * limit;
                int end = Math.min(start + limit, fullList.size());

                List<T> page = (start < fullList.size()) ? fullList.subList(start, end) : List.of();
                boolean moreRecords = end < fullList.size();
                Integer nextCursor = moreRecords ? currentPage + 1 : null;

                return new PagedResponse<>(page, nextCursor, moreRecords);
            });
    }
}